<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConditionCompiler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Card Fraud Rule Engine</a> &gt; <a href="index.source.html" class="el_package">com.fraud.engine.engine</a> &gt; <span class="el_source">ConditionCompiler.java</span></div><h1>ConditionCompiler.java</h1><pre class="source lang-java linenums"><span class="fc" id="L1">package com.fraud.engine.engine;</span>

import com.fraud.engine.domain.Condition;
import com.fraud.engine.domain.CompiledCondition;
import com.fraud.engine.domain.FieldRegistry;
import com.fraud.engine.domain.TransactionContext;
import com.fraud.engine.service.FieldRegistryService;
import jakarta.annotation.PostConstruct;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import org.jboss.logging.Logger;

import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

/**
 * Compiles conditions into executable lambdas for high-performance evaluation.
 * &lt;p&gt;
 * This compiler transforms {@link Condition} objects (which use string-based field lookup)
 * into {@link CompiledCondition} lambdas (which use direct field access).
 * &lt;p&gt;
 * Phase 5: Now uses {@link Condition.Operator} enum for faster switching.
 * &lt;p&gt;
 * Phase 6: Now uses {@link FieldRegistryService} for dynamic field loading,
 * with fallback to static {@link FieldRegistry} for backward compatibility.
 * &lt;p&gt;
 * The compiler is a CDI bean that can be injected, but also provides static
 * methods for backward compatibility with existing code and tests.
 * &lt;p&gt;
 * Performance benefits:
 * &lt;ul&gt;
 *   &lt;li&gt;Direct array access via {@link TransactionContext#getField(int)} instead of HashMap&lt;/li&gt;
 *   &lt;li&gt;No string allocations for field lookups&lt;/li&gt;
 *   &lt;li&gt;Better JIT inlining (lambdas are easier to inline than reflective calls)&lt;/li&gt;
 *   &lt;li&gt;Monomorphic call sites enable better optimization&lt;/li&gt;
 *   &lt;li&gt;Enum switch instead of string switch for operator dispatch&lt;/li&gt;
 * &lt;/ul&gt;
 */
@ApplicationScoped
<span class="fc" id="L41">public class ConditionCompiler {</span>

<span class="fc" id="L43">    private static final Logger LOG = Logger.getLogger(ConditionCompiler.class);</span>

    // Singleton instance for static method delegates (set by CDI)
<span class="fc" id="L46">    private static volatile ConditionCompiler instance;</span>

    @Inject
    FieldRegistryService fieldRegistryService;

    /**
     * Initializes the compiler and sets the singleton instance for static delegates.
     */
    @PostConstruct
    void init() {
<span class="nc" id="L56">        instance = this;</span>
<span class="nc" id="L57">        LOG.debug(&quot;ConditionCompiler instance initialized for static delegates&quot;);</span>
<span class="nc" id="L58">    }</span>

    // ========== Static Methods (for backward compatibility) ==========

    /**
     * Compiles a single condition into a lambda predicate (static delegate).
     *
     * @param condition the condition to compile
     * @return a compiled condition that can be evaluated efficiently
     */
    public static CompiledCondition compile(Condition condition) {
<span class="fc" id="L69">        return getInstance().compileCondition(condition);</span>
    }

    /**
     * Compiles a list of conditions (AND logic - all must match) (static delegate).
     *
     * @param conditions the conditions to compile
     * @return a compiled condition that matches only if all input conditions match
     */
    public static CompiledCondition compileAll(List&lt;Condition&gt; conditions) {
<span class="fc" id="L79">        return getInstance().compileAllConditions(conditions);</span>
    }

    /**
     * Gets the singleton instance.
     * Falls back to a no-op instance if CDI hasn't initialized yet (for tests).
     */
    private static ConditionCompiler getInstance() {
<span class="fc" id="L87">        ConditionCompiler result = instance;</span>
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">        if (result == null) {</span>
            // Fallback for tests or non-CDI contexts
<span class="fc" id="L90">            LOG.debug(&quot;ConditionCompiler instance not available, using fallback&quot;);</span>
<span class="fc" id="L91">            return new ConditionCompiler();</span>
        }
<span class="nc" id="L93">        return result;</span>
    }

    // ========== Instance Methods ==========

    /**
     * Compiles a single condition into a lambda predicate (instance method).
     *
     * @param condition the condition to compile
     * @return a compiled condition that can be evaluated efficiently
     */
    public CompiledCondition compileCondition(Condition condition) {
<span class="fc" id="L105">        String fieldName = condition.getField();</span>
<span class="fc" id="L106">        Condition.Operator operator = condition.getOperatorEnum();</span>
<span class="fc" id="L107">        Object expectedValue = condition.getValue();</span>
<span class="fc" id="L108">        Object values = condition.getValues();</span>

        // Get field ID from registry (tries service first, falls back to static)
<span class="fc" id="L111">        int fieldId = getFieldId(fieldName);</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">        if (!FieldRegistry.isValid(fieldId)) {</span>
<span class="fc" id="L113">            return compileCustomFieldCondition(fieldName, operator, expectedValue, values);</span>
        }

        // Phase 5: Use enum switch (faster than string comparison)
        CompiledCondition result;
<span class="fc bfc" id="L118" title="All 2 branches covered.">        if (operator == null) {</span>
<span class="fc" id="L119">            LOG.warnf(&quot;Null operator for field %s, defaulting to false&quot;, fieldName);</span>
<span class="fc" id="L120">            result = tx -&gt; false;</span>
<span class="fc" id="L121">        } else {</span>
<span class="fc bfc" id="L122" title="All 14 branches covered.">            result = switch (operator) {</span>
<span class="fc" id="L123">                case GT -&gt; compileGreaterThan(fieldId, expectedValue);</span>
<span class="fc" id="L124">                case GTE -&gt; compileGreaterThanOrEqual(fieldId, expectedValue);</span>
<span class="fc" id="L125">                case LT -&gt; compileLessThan(fieldId, expectedValue);</span>
<span class="fc" id="L126">                case LTE -&gt; compileLessThanOrEqual(fieldId, expectedValue);</span>
<span class="fc" id="L127">                case EQ -&gt; compileEquals(fieldId, expectedValue);</span>
<span class="fc" id="L128">                case NE -&gt; compileNotEquals(fieldId, expectedValue);</span>
<span class="fc" id="L129">                case IN -&gt; compileInList(fieldId, values, expectedValue);</span>
<span class="fc" id="L130">                case NOT_IN -&gt; compileNotInList(fieldId, values, expectedValue);</span>
<span class="fc" id="L131">                case BETWEEN -&gt; compileBetween(fieldId, values, expectedValue);</span>
<span class="fc" id="L132">                case CONTAINS -&gt; compileContains(fieldId, expectedValue);</span>
<span class="fc" id="L133">                case STARTS_WITH -&gt; compileStartsWith(fieldId, expectedValue);</span>
<span class="fc" id="L134">                case ENDS_WITH -&gt; compileEndsWith(fieldId, expectedValue);</span>
<span class="fc" id="L135">                case REGEX -&gt; compileRegex(fieldId, expectedValue);</span>
<span class="fc" id="L136">                case EXISTS -&gt; compileExists(fieldId);</span>
            };
        }
<span class="fc" id="L139">        return result;</span>
    }

    /**
     * Compiles a list of conditions (AND logic - all must match) (instance method).
     *
     * @param conditions the conditions to compile
     * @return a compiled condition that matches only if all input conditions match
     */
    public CompiledCondition compileAllConditions(List&lt;Condition&gt; conditions) {
<span class="pc bpc" id="L149" title="1 of 4 branches missed.">        if (conditions == null || conditions.isEmpty()) {</span>
<span class="fc" id="L150">            return tx -&gt; true; // Empty condition list = matches all</span>
        }

<span class="fc bfc" id="L153" title="All 2 branches covered.">        if (conditions.size() == 1) {</span>
<span class="fc" id="L154">            return compileCondition(conditions.get(0));</span>
        }

        // Combine all conditions with AND - use array for efficiency
<span class="fc" id="L158">        CompiledCondition[] compiled = conditions.stream()</span>
<span class="fc" id="L159">                .map(this::compileCondition)</span>
<span class="fc" id="L160">                .toArray(CompiledCondition[]::new);</span>

<span class="fc" id="L162">        return tx -&gt; {</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">            for (CompiledCondition c : compiled) {</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">                if (!c.matches(tx)) {</span>
<span class="fc" id="L165">                    return false; // Short-circuit on first failure</span>
                }
            }
<span class="fc" id="L168">            return true;</span>
        };
    }

    // ========== Compiler Methods ==========

    private CompiledCondition compileGreaterThan(int fieldId, Object expectedValue) {
<span class="fc bfc" id="L175" title="All 2 branches covered.">        if (!(expectedValue instanceof Number)) {</span>
<span class="fc" id="L176">            return tx -&gt; false;</span>
        }
<span class="fc" id="L178">        double threshold = ((Number) expectedValue).doubleValue();</span>
<span class="fc" id="L179">        return tx -&gt; {</span>
<span class="fc" id="L180">            Object actual = tx.getField(fieldId);</span>
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">            if (actual instanceof Number n) {</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">                return n.doubleValue() &gt; threshold;</span>
            }
<span class="nc" id="L184">            return false;</span>
        };
    }

    private CompiledCondition compileGreaterThanOrEqual(int fieldId, Object expectedValue) {
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">        if (!(expectedValue instanceof Number)) {</span>
<span class="nc" id="L190">            return tx -&gt; false;</span>
        }
<span class="fc" id="L192">        double threshold = ((Number) expectedValue).doubleValue();</span>
<span class="fc" id="L193">        return tx -&gt; {</span>
<span class="fc" id="L194">            Object actual = tx.getField(fieldId);</span>
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">            if (actual instanceof Number n) {</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">                return n.doubleValue() &gt;= threshold;</span>
            }
<span class="nc" id="L198">            return false;</span>
        };
    }

    private CompiledCondition compileLessThan(int fieldId, Object expectedValue) {
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">        if (!(expectedValue instanceof Number)) {</span>
<span class="nc" id="L204">            return tx -&gt; false;</span>
        }
<span class="fc" id="L206">        double threshold = ((Number) expectedValue).doubleValue();</span>
<span class="fc" id="L207">        return tx -&gt; {</span>
<span class="fc" id="L208">            Object actual = tx.getField(fieldId);</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">            if (actual instanceof Number n) {</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">                return n.doubleValue() &lt; threshold;</span>
            }
<span class="nc" id="L212">            return false;</span>
        };
    }

    private CompiledCondition compileLessThanOrEqual(int fieldId, Object expectedValue) {
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">        if (!(expectedValue instanceof Number)) {</span>
<span class="nc" id="L218">            return tx -&gt; false;</span>
        }
<span class="fc" id="L220">        double threshold = ((Number) expectedValue).doubleValue();</span>
<span class="fc" id="L221">        return tx -&gt; {</span>
<span class="fc" id="L222">            Object actual = tx.getField(fieldId);</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">            if (actual instanceof Number n) {</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">                return n.doubleValue() &lt;= threshold;</span>
            }
<span class="nc" id="L226">            return false;</span>
        };
    }

    private CompiledCondition compileEquals(int fieldId, Object expectedValue) {
<span class="fc" id="L231">        return tx -&gt; {</span>
<span class="fc" id="L232">            Object actual = tx.getField(fieldId);</span>
<span class="pc bpc" id="L233" title="3 of 4 branches missed.">            if (actual == null &amp;&amp; expectedValue == null) return true;</span>
<span class="pc bpc" id="L234" title="2 of 4 branches missed.">            if (actual == null || expectedValue == null) return false;</span>

            // Numeric comparison
<span class="pc bpc" id="L237" title="1 of 4 branches missed.">            if (actual instanceof Number actualNum &amp;&amp; expectedValue instanceof Number expectedNum) {</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">                return compareNumeric(actualNum, expectedNum) == 0;</span>
            }

            // String comparison
<span class="fc" id="L242">            return actual.equals(expectedValue);</span>
        };
    }

    private CompiledCondition compileNotEquals(int fieldId, Object expectedValue) {
<span class="fc" id="L247">        CompiledCondition eq = compileEquals(fieldId, expectedValue);</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">        return tx -&gt; !eq.matches(tx);</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private CompiledCondition compileInList(int fieldId, Object values, Object singleValue) {
<span class="fc" id="L253">        List&lt;Object&gt; targetList = extractList(values, singleValue);</span>
<span class="pc bpc" id="L254" title="2 of 4 branches missed.">        if (targetList == null || targetList.isEmpty()) {</span>
<span class="nc" id="L255">            return tx -&gt; false;</span>
        }

<span class="fc" id="L258">        return tx -&gt; {</span>
<span class="fc" id="L259">            Object actual = tx.getField(fieldId);</span>
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">            if (actual == null) return false;</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">            for (Object item : targetList) {</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">                if (actual.equals(item)) {</span>
<span class="fc" id="L263">                    return true;</span>
                }
            }
<span class="fc" id="L266">            return false;</span>
        };
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private CompiledCondition compileNotInList(int fieldId, Object values, Object singleValue) {
<span class="fc" id="L272">        CompiledCondition inCondition = compileInList(fieldId, values, singleValue);</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">        return tx -&gt; !inCondition.matches(tx);</span>
    }

    private CompiledCondition compileBetween(int fieldId, Object values, Object singleValue) {
<span class="fc" id="L277">        List&lt;Object&gt; range = extractList(values, singleValue);</span>
<span class="pc bpc" id="L278" title="2 of 4 branches missed.">        if (range == null || range.size() &lt; 2) {</span>
<span class="nc" id="L279">            return tx -&gt; false;</span>
        }
<span class="fc" id="L281">        Object lower = range.get(0);</span>
<span class="fc" id="L282">        Object upper = range.get(1);</span>
<span class="pc bpc" id="L283" title="2 of 4 branches missed.">        if (!(lower instanceof Number) || !(upper instanceof Number)) {</span>
<span class="nc" id="L284">            return tx -&gt; false;</span>
        }
<span class="fc" id="L286">        double min = ((Number) lower).doubleValue();</span>
<span class="fc" id="L287">        double max = ((Number) upper).doubleValue();</span>
<span class="fc" id="L288">        double low = Math.min(min, max);</span>
<span class="fc" id="L289">        double high = Math.max(min, max);</span>
<span class="fc" id="L290">        return tx -&gt; {</span>
<span class="fc" id="L291">            Object actual = tx.getField(fieldId);</span>
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">            if (actual instanceof Number n) {</span>
<span class="fc" id="L293">                double val = n.doubleValue();</span>
<span class="pc bpc" id="L294" title="1 of 4 branches missed.">                return val &gt;= low &amp;&amp; val &lt;= high;</span>
            }
<span class="nc" id="L296">            return false;</span>
        };
    }

    private CompiledCondition compileContains(int fieldId, Object expectedValue) {
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">        if (expectedValue == null) {</span>
<span class="nc" id="L302">            return tx -&gt; false;</span>
        }
<span class="fc" id="L304">        String search = String.valueOf(expectedValue);</span>
<span class="fc" id="L305">        return tx -&gt; {</span>
<span class="fc" id="L306">            Object actual = tx.getField(fieldId);</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">            if (actual instanceof String s) {</span>
<span class="fc" id="L308">                return s.contains(search);</span>
            }
<span class="nc" id="L310">            return false;</span>
        };
    }

    private CompiledCondition compileStartsWith(int fieldId, Object expectedValue) {
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">        if (expectedValue == null) {</span>
<span class="nc" id="L316">            return tx -&gt; false;</span>
        }
<span class="fc" id="L318">        String prefix = String.valueOf(expectedValue);</span>
<span class="fc" id="L319">        return tx -&gt; {</span>
<span class="fc" id="L320">            Object actual = tx.getField(fieldId);</span>
<span class="pc bpc" id="L321" title="1 of 4 branches missed.">            return actual instanceof String s &amp;&amp; s.startsWith(prefix);</span>
        };
    }

    private CompiledCondition compileEndsWith(int fieldId, Object expectedValue) {
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">        if (expectedValue == null) {</span>
<span class="nc" id="L327">            return tx -&gt; false;</span>
        }
<span class="fc" id="L329">        String suffix = String.valueOf(expectedValue);</span>
<span class="fc" id="L330">        return tx -&gt; {</span>
<span class="fc" id="L331">            Object actual = tx.getField(fieldId);</span>
<span class="pc bpc" id="L332" title="1 of 4 branches missed.">            return actual instanceof String s &amp;&amp; s.endsWith(suffix);</span>
        };
    }

    private CompiledCondition compileRegex(int fieldId, Object expectedValue) {
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">        if (expectedValue == null) {</span>
<span class="nc" id="L338">            return tx -&gt; false;</span>
        }
<span class="fc" id="L340">        String pattern = String.valueOf(expectedValue);</span>
        try {
<span class="fc" id="L342">            Pattern compiledPattern = Pattern.compile(pattern);</span>
<span class="fc" id="L343">            return tx -&gt; {</span>
<span class="fc" id="L344">                Object actual = tx.getField(fieldId);</span>
<span class="pc bpc" id="L345" title="1 of 4 branches missed.">                return actual instanceof String s &amp;&amp; compiledPattern.matcher(s).matches();</span>
            };
<span class="fc" id="L347">        } catch (Exception e) {</span>
<span class="fc" id="L348">            LOG.warnf(&quot;Invalid regex pattern: %s&quot;, pattern);</span>
<span class="fc" id="L349">            return tx -&gt; false;</span>
        }
    }

    private CompiledCondition compileExists(int fieldId) {
<span class="fc bfc" id="L354" title="All 2 branches covered.">        return tx -&gt; tx.getField(fieldId) != null;</span>
    }

    private CompiledCondition compileCustomFieldCondition(
            String fieldName,
            Condition.Operator operator,
            Object expectedValue,
            Object values) {
<span class="pc bpc" id="L362" title="2 of 4 branches missed.">        if (fieldName == null || operator == null) {</span>
<span class="nc" id="L363">            return tx -&gt; false;</span>
        }
<span class="fc" id="L365">        Condition condition = new Condition();</span>
<span class="fc" id="L366">        condition.setField(fieldName);</span>
<span class="fc" id="L367">        condition.setOperatorEnum(operator);</span>
<span class="fc" id="L368">        condition.setValue(expectedValue);</span>
<span class="fc" id="L369">        condition.setValues(values);</span>
<span class="fc" id="L370">        return tx -&gt; {</span>
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">            Map&lt;String, Object&gt; customFields = tx != null ? tx.getCustomFields() : null;</span>
<span class="fc" id="L372">            return condition.evaluate(customFields);</span>
        };
    }

    // ========== Helper Methods ==========

    @SuppressWarnings(&quot;unchecked&quot;)
    private List&lt;Object&gt; extractList(Object values, Object singleValue) {
<span class="fc bfc" id="L380" title="All 2 branches covered.">        if (values instanceof List&lt;?&gt; list) {</span>
<span class="fc" id="L381">            return (List&lt;Object&gt;) values;</span>
        }
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">        if (singleValue instanceof List&lt;?&gt; list) {</span>
<span class="nc" id="L384">            return (List&lt;Object&gt;) singleValue;</span>
        }
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">        if (singleValue != null) {</span>
<span class="fc" id="L387">            return List.of(singleValue);</span>
        }
<span class="nc" id="L389">        return null;</span>
    }

    private static int compareNumeric(Number a, Number b) {
<span class="fc" id="L393">        return Double.compare(a.doubleValue(), b.doubleValue());</span>
    }

    /**
     * Gets the field ID for a given field name.
     * &lt;p&gt;
     * Phase 6: Uses FieldRegistryService if available (dynamic fields from S3),
     * with fallback to static FieldRegistry for backward compatibility.
     *
     * @param fieldName the field name (e.g., &quot;card_hash&quot;, &quot;amount&quot;)
     * @return the field ID, or {@link FieldRegistry#UNKNOWN} if not found
     */
    private int getFieldId(String fieldName) {
        // Try FieldRegistryService first (dynamic fields from S3)
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">        if (fieldRegistryService != null) {</span>
<span class="nc" id="L408">            int id = fieldRegistryService.getFieldId(fieldName);</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">            if (id != FieldRegistry.UNKNOWN) {</span>
<span class="nc" id="L410">                return id;</span>
            }
        }

        // Fallback to static FieldRegistry (builtin fields)
<span class="fc" id="L415">        return FieldRegistry.fromName(fieldName);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>