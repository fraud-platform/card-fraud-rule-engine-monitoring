<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AsyncOutboxDispatcher.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Card Fraud Rule Engine</a> &gt; <a href="index.source.html" class="el_package">com.fraud.engine.outbox</a> &gt; <span class="el_source">AsyncOutboxDispatcher.java</span></div><h1>AsyncOutboxDispatcher.java</h1><pre class="source lang-java linenums">package com.fraud.engine.outbox;

import com.fraud.engine.domain.Decision;
import com.fraud.engine.domain.TransactionContext;
import com.fraud.engine.engine.RuleEvaluator;
import com.fraud.engine.util.EngineMetrics;
import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import org.eclipse.microprofile.config.inject.ConfigProperty;
import org.jboss.logging.Logger;

import java.util.UUID;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * Async durability dispatcher for AUTH.
 *
 * &lt;p&gt;Request thread does an in-memory enqueue only; background thread persists to the configured outbox.
 * If the queue is full, the event is dropped and AUTH response is never blocked.
 */
@ApplicationScoped
<span class="fc" id="L28">public class AsyncOutboxDispatcher {</span>

<span class="fc" id="L30">    private static final Logger LOG = Logger.getLogger(AsyncOutboxDispatcher.class);</span>
    private static final int MAX_DRAIN_BURST = 64;

    @ConfigProperty(name = &quot;app.auth.async-durability.enabled&quot;, defaultValue = &quot;true&quot;)
    boolean enabled;

    @ConfigProperty(name = &quot;app.auth.async-durability.queue-capacity&quot;, defaultValue = &quot;10000&quot;)
    int queueCapacity;

    @ConfigProperty(name = &quot;app.auth.async-durability.poll-interval-ms&quot;, defaultValue = &quot;5&quot;)
    int pollIntervalMs;

    @Inject
    OutboxFacade outboxClient;

    @Inject
    EngineMetrics engineMetrics;

    private BlockingQueue&lt;OutboxEvent&gt; queue;
<span class="fc" id="L49">    private final ExecutorService worker = Executors.newSingleThreadExecutor(</span>
            r -&gt; {
<span class="nc" id="L51">                Thread t = new Thread(r, &quot;auth-async-durability-writer-&quot; + UUID.randomUUID());</span>
<span class="nc" id="L52">                t.setDaemon(true);</span>
<span class="nc" id="L53">                return t;</span>
            });

    private volatile boolean running;
    private volatile OutboxEvent pending;

    @PostConstruct
    void start() {
<span class="nc" id="L61">        queue = new ArrayBlockingQueue&lt;&gt;(Math.max(1, queueCapacity));</span>
<span class="nc" id="L62">        engineMetrics.setAuthAsyncQueueDepth(0);</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">        if (!enabled) {</span>
<span class="nc" id="L64">            LOG.info(&quot;AUTH async durability is DISABLED (no outbox persistence for AUTH)&quot;);</span>
<span class="nc" id="L65">            return;</span>
        }
<span class="nc" id="L67">        running = true;</span>
<span class="nc" id="L68">        worker.submit(this::runLoop);</span>
<span class="nc" id="L69">        LOG.infof(&quot;AUTH async durability enabled (queueCapacity=%d, idleWaitMs=%d)&quot;,</span>
<span class="nc" id="L70">                queueCapacity, Math.max(1, pollIntervalMs));</span>
<span class="nc" id="L71">    }</span>

    @PreDestroy
    void stop() {
<span class="nc" id="L75">        running = false;</span>
<span class="nc" id="L76">        worker.shutdownNow();</span>
<span class="nc" id="L77">    }</span>

    /**
     * Enqueue AUTH event for async durability.
     * Returns true if queued, false if dropped/disabled.
     */
    public boolean enqueueAuth(TransactionContext tx, Decision authDecision) {
<span class="nc bnc" id="L84" title="All 2 branches missed.">        if (!enabled) {</span>
<span class="nc" id="L85">            engineMetrics.incrementAuthAsyncDurabilityDisabledDrops();</span>
<span class="nc" id="L86">            engineMetrics.incrementAuthAsyncEnqueueDropped();</span>
<span class="nc" id="L87">            return false;</span>
        }
<span class="nc bnc" id="L89" title="All 4 branches missed.">        if (tx == null || authDecision == null) {</span>
<span class="nc" id="L90">            engineMetrics.incrementAuthAsyncDurabilityInvalidDrops();</span>
<span class="nc" id="L91">            engineMetrics.incrementAuthAsyncEnqueueDropped();</span>
<span class="nc" id="L92">            return false;</span>
        }
<span class="nc bnc" id="L94" title="All 2 branches missed.">        if (!RuleEvaluator.EVAL_AUTH.equalsIgnoreCase(authDecision.getEvaluationType())) {</span>
            // Defensive: only intended for AUTH
<span class="nc" id="L96">            engineMetrics.incrementAuthAsyncDurabilityInvalidDrops();</span>
<span class="nc" id="L97">            engineMetrics.incrementAuthAsyncEnqueueDropped();</span>
<span class="nc" id="L98">            return false;</span>
        }

<span class="nc" id="L101">        boolean offered = queue.offer(new OutboxEvent(tx, authDecision));</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">        if (offered) {</span>
<span class="nc" id="L103">            engineMetrics.incrementAuthAsyncDurabilityEnqueued();</span>
<span class="nc" id="L104">            engineMetrics.incrementAuthAsyncEnqueueOk();</span>
        } else {
<span class="nc" id="L106">            engineMetrics.incrementAuthAsyncDurabilityQueueFullDrops();</span>
<span class="nc" id="L107">            engineMetrics.incrementAuthAsyncEnqueueDropped();</span>
        }
<span class="nc" id="L109">        engineMetrics.setAuthAsyncQueueDepth(queue.size());</span>
<span class="nc" id="L110">        return offered;</span>
    }

    private void runLoop() {
<span class="nc bnc" id="L114" title="All 4 branches missed.">        while (running &amp;&amp; !Thread.currentThread().isInterrupted()) {</span>
            try {
<span class="nc" id="L116">                drainLoopIteration();</span>
<span class="nc" id="L117">            } catch (InterruptedException ie) {</span>
<span class="nc" id="L118">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L119">                return;</span>
<span class="nc" id="L120">            } catch (Exception e) {</span>
<span class="nc" id="L121">                LOG.warnf(e, &quot;AUTH async durability drain iteration failed&quot;);</span>
<span class="nc" id="L122">                sleepBackoff();</span>
<span class="nc" id="L123">            }</span>
        }
<span class="nc" id="L125">    }</span>

    private void drainLoopIteration() throws InterruptedException {
<span class="nc" id="L128">        OutboxEvent current = pending;</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        if (current == null) {</span>
<span class="nc" id="L130">            current = queue.poll(Math.max(1, pollIntervalMs), TimeUnit.MILLISECONDS);</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">            if (current == null) {</span>
<span class="nc" id="L132">                engineMetrics.setAuthAsyncQueueDepth(queue.size());</span>
<span class="nc" id="L133">                return;</span>
            }
        }

<span class="nc bnc" id="L137" title="All 2 branches missed.">        if (!persist(current)) {</span>
<span class="nc" id="L138">            pending = current;</span>
<span class="nc" id="L139">            sleepBackoff();</span>
<span class="nc" id="L140">            return;</span>
        }

<span class="nc" id="L143">        pending = null;</span>
<span class="nc" id="L144">        drainBurst();</span>
<span class="nc" id="L145">        engineMetrics.setAuthAsyncQueueDepth(queue.size());</span>
<span class="nc" id="L146">    }</span>

    private void drainBurst() {
<span class="nc bnc" id="L149" title="All 2 branches missed.">        for (int i = 0; i &lt; MAX_DRAIN_BURST; i++) {</span>
<span class="nc" id="L150">            OutboxEvent next = queue.poll();</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">            if (next == null) {</span>
<span class="nc" id="L152">                return;</span>
            }
<span class="nc bnc" id="L154" title="All 2 branches missed.">            if (!persist(next)) {</span>
<span class="nc" id="L155">                pending = next;</span>
<span class="nc" id="L156">                return;</span>
            }
        }
<span class="nc" id="L159">    }</span>

    private boolean persist(OutboxEvent event) {
        try {
<span class="nc" id="L163">            outboxClient.append(event);</span>
<span class="nc" id="L164">            engineMetrics.incrementAuthAsyncDurabilityPersisted();</span>
<span class="nc" id="L165">            return true;</span>
<span class="nc" id="L166">        } catch (Exception e) {</span>
<span class="nc" id="L167">            engineMetrics.incrementAuthAsyncDurabilityPersistFailures();</span>
            // Keep pending and retry later; do not block request threads.
<span class="nc" id="L169">            LOG.debugf(e, &quot;AUTH async durability persist failed (will retry)&quot;);</span>
<span class="nc" id="L170">            return false;</span>
        }
    }

    private void sleepBackoff() {
        try {
<span class="nc" id="L176">            TimeUnit.MILLISECONDS.sleep(Math.max(1, pollIntervalMs));</span>
<span class="nc" id="L177">        } catch (InterruptedException ie) {</span>
<span class="nc" id="L178">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L179">        }</span>
<span class="nc" id="L180">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>