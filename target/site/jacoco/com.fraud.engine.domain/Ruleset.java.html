<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Ruleset.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Card Fraud Rule Engine</a> &gt; <a href="index.source.html" class="el_package">com.fraud.engine.domain</a> &gt; <span class="el_source">Ruleset.java</span></div><h1>Ruleset.java</h1><pre class="source lang-java linenums"><span class="fc" id="L1">package com.fraud.engine.domain;</span>

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

import java.time.Instant;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Represents a ruleset containing a collection of rules.
 *
 * A ruleset is identified by a key and version, and contains:
 * - Rules that will be evaluated
 * - Metadata (version, created timestamp, etc.)
 * - Evaluation mode (AUTH or MONITORING)
 * - Compiled rules for high-performance evaluation
 * - Scope buckets for efficient rule filtering
 */
public class Ruleset {
    private static final int APPLICABLE_RULE_CACHE_MAX_ENTRIES = 2048;

    @NotBlank(message = &quot;Ruleset key is required&quot;)
    @JsonProperty(&quot;key&quot;)
    private String key;

    @NotNull(message = &quot;Version is required&quot;)
    @JsonProperty(&quot;version&quot;)
    private Integer version;

    @JsonProperty(&quot;name&quot;)
    private String name;

    @JsonProperty(&quot;description&quot;)
    private String description;

    @JsonProperty(&quot;evaluation_type&quot;)
    private String evaluationType;

    @JsonProperty(&quot;rules&quot;)
<span class="fc" id="L47">    private List&lt;Rule&gt; rules = new ArrayList&lt;&gt;();</span>

    private volatile List&lt;Rule&gt; cachedSortedRules;

    @JsonProperty(&quot;created_at&quot;)
    private Instant createdAt;

    @JsonProperty(&quot;created_by&quot;)
    private String createdBy;

    @JsonProperty(&quot;active&quot;)
<span class="fc" id="L58">    private boolean active = true;</span>

    @JsonProperty(&quot;field_registry_version&quot;)
    private Integer fieldRegistryVersion;

    @JsonProperty(&quot;ruleset_id&quot;)
    private String rulesetId;

    private transient Map&lt;String, List&lt;Rule&gt;&gt; networkBuckets;
    private transient Map&lt;String, List&lt;Rule&gt;&gt; binBuckets;
    private transient Map&lt;String, List&lt;Rule&gt;&gt; mccBuckets;
    private transient Map&lt;String, List&lt;Rule&gt;&gt; logoBuckets;
    private transient List&lt;Rule&gt; globalRules;
<span class="fc" id="L71">    private transient volatile boolean scopeBucketsBuilt = false;</span>
    private transient volatile ConcurrentHashMap&lt;ScopeCacheKey, List&lt;Rule&gt;&gt; applicableRulesCache;

<span class="fc" id="L74">    public Ruleset() {</span>
<span class="fc" id="L75">    }</span>

<span class="fc" id="L77">    public Ruleset(String key, Integer version) {</span>
<span class="fc" id="L78">        this.key = key;</span>
<span class="fc" id="L79">        this.version = version;</span>
<span class="fc" id="L80">    }</span>

    public String getKey() {
<span class="fc" id="L83">        return key;</span>
    }

    public void setKey(String key) {
<span class="fc" id="L87">        this.key = key;</span>
<span class="fc" id="L88">    }</span>

    public Integer getVersion() {
<span class="fc" id="L91">        return version;</span>
    }

    public void setVersion(Integer version) {
<span class="nc" id="L95">        this.version = version;</span>
<span class="nc" id="L96">    }</span>

    public String getName() {
<span class="nc" id="L99">        return name;</span>
    }

    public void setName(String name) {
<span class="fc" id="L103">        this.name = name;</span>
<span class="fc" id="L104">    }</span>

    public String getDescription() {
<span class="nc" id="L107">        return description;</span>
    }

    public void setDescription(String description) {
<span class="nc" id="L111">        this.description = description;</span>
<span class="nc" id="L112">    }</span>

    public String getEvaluationType() {
<span class="fc" id="L115">        return evaluationType;</span>
    }

    public void setEvaluationType(String evaluationType) {
<span class="fc" id="L119">        this.evaluationType = evaluationType;</span>
<span class="fc" id="L120">    }</span>

    public List&lt;Rule&gt; getRules() {
<span class="fc" id="L123">        return rules;</span>
    }

    public void setRules(List&lt;Rule&gt; rules) {
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">        this.rules = rules != null ? new ArrayList&lt;&gt;(rules) : new ArrayList&lt;&gt;();</span>
<span class="fc" id="L128">        invalidateCachedRules();</span>
<span class="fc" id="L129">        this.scopeBucketsBuilt = false;</span>
<span class="fc" id="L130">        this.applicableRulesCache = null;</span>
<span class="fc" id="L131">    }</span>

    public void addRule(Rule rule) {
<span class="fc" id="L134">        this.rules.add(rule);</span>
<span class="fc" id="L135">        invalidateCachedRules();</span>
<span class="fc" id="L136">        this.scopeBucketsBuilt = false;</span>
<span class="fc" id="L137">        this.applicableRulesCache = null;</span>
<span class="fc" id="L138">    }</span>

    /**
     * Invalidates cached sorted rules.
     */
    public void invalidateCachedRules() {
<span class="fc" id="L144">        synchronized (this) {</span>
<span class="fc" id="L145">            cachedSortedRules = null;</span>
        }
<span class="fc" id="L147">        applicableRulesCache = null;</span>
<span class="fc" id="L148">    }</span>

    public Instant getCreatedAt() {
<span class="nc" id="L151">        return createdAt;</span>
    }

    public void setCreatedAt(Instant createdAt) {
<span class="nc" id="L155">        this.createdAt = createdAt;</span>
<span class="nc" id="L156">    }</span>

    public String getCreatedBy() {
<span class="nc" id="L159">        return createdBy;</span>
    }

    public void setCreatedBy(String createdBy) {
<span class="nc" id="L163">        this.createdBy = createdBy;</span>
<span class="nc" id="L164">    }</span>

    public boolean isActive() {
<span class="fc" id="L167">        return active;</span>
    }

    public void setActive(boolean active) {
<span class="fc" id="L171">        this.active = active;</span>
<span class="fc" id="L172">    }</span>

    /**
     * Gets the field registry version required by this ruleset.
     *
     * @return the field registry version, or null if not specified (legacy ruleset)
     */
    public Integer getFieldRegistryVersion() {
<span class="nc" id="L180">        return fieldRegistryVersion;</span>
    }

    /**
     * Sets the field registry version required by this ruleset.
     *
     * @param fieldRegistryVersion the field registry version
     */
    public void setFieldRegistryVersion(Integer fieldRegistryVersion) {
<span class="fc" id="L189">        this.fieldRegistryVersion = fieldRegistryVersion;</span>
<span class="fc" id="L190">    }</span>

    public String getRulesetId() {
<span class="fc" id="L193">        return rulesetId;</span>
    }

    public void setRulesetId(String rulesetId) {
<span class="nc" id="L197">        this.rulesetId = rulesetId;</span>
<span class="nc" id="L198">    }</span>

    /**
     * Builds scope buckets for efficient rule filtering.
     * Called automatically on first getApplicableRules() call.
     */
    private void buildScopeBuckets() {
<span class="fc bfc" id="L205" title="All 2 branches covered.">        if (scopeBucketsBuilt) {</span>
<span class="fc" id="L206">            return;</span>
        }
<span class="fc" id="L208">        synchronized (this) {</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">            if (scopeBucketsBuilt) {</span>
<span class="nc" id="L210">                return;</span>
            }
<span class="fc" id="L212">            networkBuckets = new HashMap&lt;&gt;();</span>
<span class="fc" id="L213">            binBuckets = new HashMap&lt;&gt;();</span>
<span class="fc" id="L214">            mccBuckets = new HashMap&lt;&gt;();</span>
<span class="fc" id="L215">            logoBuckets = new HashMap&lt;&gt;();</span>
<span class="fc" id="L216">            globalRules = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L217">            applicableRulesCache = new ConcurrentHashMap&lt;&gt;();</span>

<span class="fc bfc" id="L219" title="All 2 branches covered.">            for (Rule rule : rules) {</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">                if (!rule.isEnabled()) {</span>
<span class="fc" id="L221">                    continue;</span>
                }
<span class="fc" id="L223">                RuleScope scope = rule.getScope();</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">                if (scope == null) {</span>
<span class="nc" id="L225">                    globalRules.add(rule);</span>
<span class="nc" id="L226">                    continue;</span>
                }
<span class="pc bpc" id="L228" title="1 of 6 branches missed.">                switch (scope.getType()) {</span>
                    case NETWORK -&gt; {
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">                        if (scope.getValue() != null) {</span>
<span class="fc" id="L231">                            networkBuckets.computeIfAbsent(scope.getValue().toUpperCase(), k -&gt; new ArrayList&lt;&gt;()).add(rule);</span>
                        }
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">                        if (scope.getValues() != null) {</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">                            for (String val : scope.getValues()) {</span>
<span class="nc" id="L235">                                networkBuckets.computeIfAbsent(val.toUpperCase(), k -&gt; new ArrayList&lt;&gt;()).add(rule);</span>
                            }
                        }
                    }
                    case BIN -&gt; {
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">                        if (scope.getValue() != null) {</span>
<span class="fc" id="L241">                            binBuckets.computeIfAbsent(scope.getValue(), k -&gt; new ArrayList&lt;&gt;()).add(rule);</span>
                        }
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">                        if (scope.getValues() != null) {</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">                            for (String val : scope.getValues()) {</span>
<span class="nc" id="L245">                                binBuckets.computeIfAbsent(val, k -&gt; new ArrayList&lt;&gt;()).add(rule);</span>
                            }
                        }
                    }
                    case MCC -&gt; {
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">                        if (scope.getValue() != null) {</span>
<span class="fc" id="L251">                            mccBuckets.computeIfAbsent(scope.getValue(), k -&gt; new ArrayList&lt;&gt;()).add(rule);</span>
                        }
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">                        if (scope.getValues() != null) {</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">                            for (String val : scope.getValues()) {</span>
<span class="nc" id="L255">                                mccBuckets.computeIfAbsent(val, k -&gt; new ArrayList&lt;&gt;()).add(rule);</span>
                            }
                        }
                    }
                    case LOGO -&gt; {
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">                        if (scope.getValue() != null) {</span>
<span class="fc" id="L261">                            logoBuckets.computeIfAbsent(scope.getValue().toUpperCase(), k -&gt; new ArrayList&lt;&gt;()).add(rule);</span>
                        }
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">                        if (scope.getValues() != null) {</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">                            for (String val : scope.getValues()) {</span>
<span class="nc" id="L265">                                logoBuckets.computeIfAbsent(val.toUpperCase(), k -&gt; new ArrayList&lt;&gt;()).add(rule);</span>
                            }
                        }
                    }
<span class="fc" id="L269">                    case GLOBAL, COMBINED -&gt; globalRules.add(rule);</span>
                }
            }
<span class="fc" id="L272">            scopeBucketsBuilt = true;</span>
        }
<span class="fc" id="L274">    }</span>

    /**
     * Gets all rules applicable to the given scope dimensions.
     * Rules are returned in order of scope specificity (most specific first).
     *
     * @param network the card network (e.g., &quot;VISA&quot;)
     * @param bin the card BIN (e.g., &quot;411111&quot;)
     * @param mcc the merchant category code (e.g., &quot;5411&quot;)
     * @param logo the card logo
     * @return list of applicable rules sorted by specificity
     */
    /**
     * ADR-0015: Scope bucket traversal comparator.
     * Order: scope specificity descending -&gt; priority descending -&gt; APPROVE-first tie-breaker.
     */
<span class="fc" id="L290">    private static final Comparator&lt;Rule&gt; SCOPE_TRAVERSAL_COMPARATOR =</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">            Comparator.comparingInt((Rule r) -&gt; r.getScope() != null ? r.getScope().getSpecificity() : 0)</span>
<span class="fc" id="L292">                    .reversed()</span>
<span class="fc" id="L293">                    .thenComparing(Comparator.comparingInt(Rule::getPriority).reversed())</span>
<span class="pc bnc" id="L294" title="All 2 branches missed.">                    .thenComparing(r -&gt; &quot;APPROVE&quot;.equalsIgnoreCase(r.getAction()) ? 0 : 1);</span>

    private record ScopeCacheKey(String network, String bin, String mcc, String logo) {
    }

    public List&lt;Rule&gt; getApplicableRules(String network, String bin, String mcc, String logo) {
<span class="fc" id="L300">        buildScopeBuckets();</span>

<span class="fc bfc" id="L302" title="All 2 branches covered.">        String normalizedNetwork = network != null ? network.toUpperCase() : null;</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">        String normalizedLogo = logo != null ? logo.toUpperCase() : null;</span>
<span class="fc" id="L304">        ScopeCacheKey cacheKey = new ScopeCacheKey(normalizedNetwork, bin, mcc, normalizedLogo);</span>

<span class="fc" id="L306">        ConcurrentHashMap&lt;ScopeCacheKey, List&lt;Rule&gt;&gt; cache = applicableRulesCache;</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">        if (cache != null) {</span>
<span class="fc" id="L308">            List&lt;Rule&gt; cached = cache.get(cacheKey);</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">            if (cached != null) {</span>
<span class="fc" id="L310">                return cached;</span>
            }
        }

<span class="fc" id="L314">        List&lt;Rule&gt; computed = computeApplicableRules(normalizedNetwork, bin, mcc, normalizedLogo);</span>

<span class="pc bpc" id="L316" title="1 of 2 branches missed.">        if (cache != null) {</span>
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">            if (cache.size() &gt;= APPLICABLE_RULE_CACHE_MAX_ENTRIES) {</span>
<span class="nc" id="L318">                cache.clear();</span>
            }
<span class="fc" id="L320">            List&lt;Rule&gt; previous = cache.putIfAbsent(cacheKey, computed);</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">            if (previous != null) {</span>
<span class="nc" id="L322">                return previous;</span>
            }
        }

<span class="fc" id="L326">        return computed;</span>
    }

    private List&lt;Rule&gt; computeApplicableRules(String normalizedNetwork, String bin, String mcc, String normalizedLogo) {
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">        List&lt;Rule&gt; applicable = new ArrayList&lt;&gt;(Math.max(8, globalRules != null ? globalRules.size() : 0));</span>

<span class="fc bfc" id="L332" title="All 2 branches covered.">        if (bin != null) {</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">            for (int len = bin.length(); len &gt;= 1; len--) {</span>
<span class="fc" id="L334">                String prefix = bin.substring(0, len);</span>
<span class="fc" id="L335">                List&lt;Rule&gt; binRules = binBuckets.get(prefix);</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">                if (binRules != null) {</span>
<span class="fc" id="L337">                    applicable.addAll(binRules);</span>
                }
            }
        }

<span class="fc bfc" id="L342" title="All 2 branches covered.">        if (mcc != null) {</span>
<span class="fc" id="L343">            List&lt;Rule&gt; mccRules = mccBuckets.get(mcc);</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">            if (mccRules != null) {</span>
<span class="fc" id="L345">                applicable.addAll(mccRules);</span>
            }
        }

<span class="fc bfc" id="L349" title="All 2 branches covered.">        if (normalizedNetwork != null) {</span>
<span class="fc" id="L350">            List&lt;Rule&gt; networkRules = networkBuckets.get(normalizedNetwork);</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">            if (networkRules != null) {</span>
<span class="fc" id="L352">                applicable.addAll(networkRules);</span>
            }
        }

<span class="fc bfc" id="L356" title="All 2 branches covered.">        if (normalizedLogo != null) {</span>
<span class="fc" id="L357">            List&lt;Rule&gt; logoRules = logoBuckets.get(normalizedLogo);</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">            if (logoRules != null) {</span>
<span class="fc" id="L359">                applicable.addAll(logoRules);</span>
            }
        }

<span class="pc bpc" id="L363" title="1 of 2 branches missed.">        if (globalRules != null) {</span>
<span class="fc" id="L364">            applicable.addAll(globalRules);</span>
        }

        // ADR-0015: Sort by scope specificity -&gt; priority -&gt; APPROVE-first
<span class="fc" id="L368">        applicable.sort(SCOPE_TRAVERSAL_COMPARATOR);</span>
<span class="fc" id="L369">        return List.copyOf(applicable);</span>
    }

    /**
     * Gets the count of rules in each scope bucket.
     *
     * @return map of scope type to rule count
     */
    public Map&lt;String, Integer&gt; getScopeBucketCounts() {
<span class="fc" id="L378">        buildScopeBuckets();</span>
<span class="fc" id="L379">        Map&lt;String, Integer&gt; counts = new HashMap&lt;&gt;();</span>
<span class="fc" id="L380">        counts.put(&quot;NETWORK&quot;, networkBuckets.values().stream().mapToInt(List::size).sum());</span>
<span class="fc" id="L381">        counts.put(&quot;BIN&quot;, binBuckets.values().stream().mapToInt(List::size).sum());</span>
<span class="fc" id="L382">        counts.put(&quot;MCC&quot;, mccBuckets.values().stream().mapToInt(List::size).sum());</span>
<span class="fc" id="L383">        counts.put(&quot;LOGO&quot;, logoBuckets.values().stream().mapToInt(List::size).sum());</span>
<span class="fc" id="L384">        counts.put(&quot;GLOBAL&quot;, globalRules.size());</span>
<span class="fc" id="L385">        counts.put(&quot;TOTAL&quot;, rules.size());</span>
<span class="fc" id="L386">        return counts;</span>
    }

    /**
     * Checks if this ruleset is compatible with a given field registry version.
     *
     * @param registryVersion the field registry version
     * @return true if compatible (versions match), false otherwise
     */
    public boolean isCompatibleWith(int registryVersion) {
<span class="fc bfc" id="L396" title="All 2 branches covered.">        if (fieldRegistryVersion == null) {</span>
            // Legacy ruleset without field_registry_version - assume compatible
<span class="fc" id="L398">            return true;</span>
        }
<span class="fc" id="L400">        return fieldRegistryVersion.equals(registryVersion);</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">        if (this == o) return true;</span>
<span class="pc bpc" id="L406" title="2 of 4 branches missed.">        if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L407">        Ruleset ruleset = (Ruleset) o;</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">        return Objects.equals(key, ruleset.key) &amp;&amp;</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">                Objects.equals(version, ruleset.version);</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L414">        return Objects.hash(key, version);</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L419">        return &quot;Ruleset{&quot; +</span>
<span class="fc" id="L420">               &quot;key='&quot; + key + '\'' +</span>
<span class="fc" id="L421">               &quot;, version=v&quot; + version +</span>
<span class="fc" id="L422">               &quot;, name='&quot; + name + '\'' +</span>
<span class="fc" id="L423">               &quot;, evaluationType='&quot; + evaluationType + '\'' +</span>
<span class="fc" id="L424">               &quot;, fieldRegistryVersion=&quot; + fieldRegistryVersion +</span>
<span class="fc" id="L425">               &quot;, rulesCount=&quot; + rules.size() +</span>
<span class="fc" id="L426">               &quot;, active=&quot; + active +</span>
               '}';
    }

    /**
     * Returns a unique identifier for this ruleset.
     */
    public String getFullKey() {
<span class="fc" id="L434">        return key + &quot;/v&quot; + version;</span>
    }

    /**
     * Gets rules sorted by priority (highest first).
     * &lt;p&gt;
     * Performance: Sorting is cached after first call. Sorting only happens:
     * &lt;ul&gt;
     *   &lt;li&gt;At ruleset load time (if preSort() is called)&lt;/li&gt;
     *   &lt;li&gt;At hot reload time&lt;/li&gt;
     *   &lt;li&gt;On first evaluation if not pre-sorted&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;
     * Uses double-checked locking for thread-safe lazy initialization.
     *
     * @return immutable list of rules sorted by priority (highest first)
     */
    public List&lt;Rule&gt; getRulesByPriority() {
<span class="fc" id="L452">        List&lt;Rule&gt; cached = cachedSortedRules;</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">        if (cached == null) {</span>
<span class="fc" id="L454">            synchronized (this) {</span>
<span class="fc" id="L455">                cached = cachedSortedRules;</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">                if (cached == null) {</span>
                    // Sort once: highest priority first
<span class="fc" id="L458">                    cached = rules.stream()</span>
<span class="fc" id="L459">                            .filter(Rule::isEnabled)</span>
<span class="fc" id="L460">                            .sorted((r1, r2) -&gt; Integer.compare(r2.getPriority(), r1.getPriority()))</span>
<span class="fc" id="L461">                            .toList();</span>
                    // Use unmodifiable list for safety and immutability
<span class="fc" id="L463">                    cachedSortedRules = cached;</span>
                }
            }
        }
<span class="fc" id="L467">        return cached;</span>
    }

    /**
     * Pre-sorts rules during loading.
     * &lt;p&gt;
     * Call this immediately after loading a ruleset to front-load the sorting cost.
     * This ensures the first evaluation doesn't incur the sorting overhead.
     * &lt;p&gt;
     * Recommended: Call in RulesetLoader after deserializing from YAML.
     */
    public void preSort() {
<span class="fc" id="L479">        getRulesByPriority(); // Triggers sorting and caching</span>
<span class="fc" id="L480">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>