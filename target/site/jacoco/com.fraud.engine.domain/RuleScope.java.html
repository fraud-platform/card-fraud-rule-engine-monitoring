<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RuleScope.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Card Fraud Rule Engine</a> &gt; <a href="index.source.html" class="el_package">com.fraud.engine.domain</a> &gt; <span class="el_source">RuleScope.java</span></div><h1>RuleScope.java</h1><pre class="source lang-java linenums">package com.fraud.engine.domain;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.util.LinkedHashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

/**
 * Represents the scope of a rule for efficient rule bucketing.
 * &lt;p&gt;
 * Scope-based routing allows the rule engine to quickly filter down to only
 * the rules that are applicable to a given transaction, significantly reducing
 * evaluation time for large rulesets.
 * &lt;p&gt;
 * Scope dimensions (in order of specificity):
 * &lt;ol&gt;
 *   &lt;li&gt;&lt;b&gt;Network&lt;/b&gt; - Card network (VISA, MASTERCARD, AMEX, DISCOVER, etc.)&lt;/li&gt;
 *   &lt;li&gt;&lt;b&gt;BIN&lt;/b&gt; - Bank Identification Number (first 6-8 digits of card)&lt;/li&gt;
 *   &lt;li&gt;&lt;b&gt;MCC&lt;/b&gt; - Merchant Category Code&lt;/li&gt;
 *   &lt;li&gt;&lt;b&gt;Logo&lt;/b&gt; - Card brand/logo (for co-branded cards)&lt;/li&gt;
 * &lt;/ol&gt;
 * &lt;p&gt;
 * Rules with more specific scopes are evaluated before less specific ones.
 * A rule with no scope (GLOBAL) applies to all transactions.
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class RuleScope {

    /**
     * Scope type enum defining the available scope dimensions.
     */
<span class="fc" id="L39">    public enum Type {</span>
<span class="fc" id="L40">        /** Global scope - applies to all transactions */</span>
<span class="fc" id="L41">        GLOBAL(0),</span>
<span class="fc" id="L42">        /** Network scope - matches card network (VISA, MASTERCARD, etc.) */</span>
<span class="fc" id="L43">        NETWORK(1),</span>
<span class="fc" id="L44">        /** BIN scope - matches Bank Identification Number prefix */</span>
<span class="fc" id="L45">        BIN(2),</span>
<span class="fc" id="L46">        /** MCC scope - matches Merchant Category Code */</span>
<span class="fc" id="L47">        MCC(3),</span>
<span class="fc" id="L48">        /** Logo scope - matches card brand/logo */</span>
<span class="fc" id="L49">        LOGO(4),</span>
<span class="fc" id="L50">        /** Combined scope - multiple dimensions */</span>
<span class="fc" id="L51">        COMBINED(5);</span>

        private final int specificity;

<span class="fc" id="L55">        Type(int specificity) {</span>
<span class="fc" id="L56">            this.specificity = specificity;</span>
<span class="fc" id="L57">        }</span>

        /**
         * Gets the specificity level for this scope type.
         * Higher values = more specific = evaluated first.
         */
        public int getSpecificity() {
<span class="fc" id="L64">            return specificity;</span>
        }
    }

    /** Global scope singleton - applies to all transactions */
<span class="fc" id="L69">    public static final RuleScope GLOBAL = new RuleScope(Type.GLOBAL, null, null, null);</span>

    private final Type type;
    private final String value;
    private final Set&lt;String&gt; values; // For multi-value scopes
    private final Map&lt;String, Set&lt;String&gt;&gt; dimensions; // For combined scopes

    // Cached hash code for performance
    private final int hashCode;

    /**
     * Creates a new rule scope with a single value.
     *
     * @param type the scope type
     * @param value the scope value (e.g., &quot;VISA&quot;, &quot;411111&quot;, &quot;5411&quot;)
     */
    public RuleScope(Type type, String value) {
<span class="fc" id="L86">        this(type, value, null, null);</span>
<span class="fc" id="L87">    }</span>

    /**
     * Creates a new rule scope with multiple values.
     *
     * @param type the scope type
     * @param values the scope values (e.g., [&quot;VISA&quot;, &quot;MASTERCARD&quot;])
     */
    public RuleScope(Type type, Set&lt;String&gt; values) {
<span class="nc" id="L96">        this(type, null, values, null);</span>
<span class="nc" id="L97">    }</span>

    @JsonCreator
<span class="fc" id="L100">    private RuleScope(</span>
            @JsonProperty(&quot;type&quot;) Type type,
            @JsonProperty(&quot;value&quot;) String value,
            @JsonProperty(&quot;values&quot;) Set&lt;String&gt; values,
            @JsonProperty(&quot;dimensions&quot;) Map&lt;String, Set&lt;String&gt;&gt; dimensions) {
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">        this.type = type != null ? type : Type.GLOBAL;</span>
<span class="fc" id="L106">        this.value = value;</span>
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">        this.values = values != null ? Set.copyOf(values) : null;</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">        this.dimensions = dimensions != null ? Map.copyOf(dimensions) : null;</span>
<span class="fc" id="L109">        this.hashCode = computeHashCode();</span>
<span class="fc" id="L110">    }</span>

    // ========== Factory Methods ==========

    /**
     * Creates a network scope.
     *
     * @param network the card network (e.g., &quot;VISA&quot;, &quot;MASTERCARD&quot;)
     * @return the network scope
     */
    public static RuleScope network(String network) {
<span class="fc" id="L121">        return new RuleScope(Type.NETWORK, network);</span>
    }

    /**
     * Creates a BIN scope.
     *
     * @param bin the BIN prefix (e.g., &quot;411111&quot;)
     * @return the BIN scope
     */
    public static RuleScope bin(String bin) {
<span class="fc" id="L131">        return new RuleScope(Type.BIN, bin);</span>
    }

    /**
     * Creates an MCC scope.
     *
     * @param mcc the merchant category code (e.g., &quot;5411&quot;)
     * @return the MCC scope
     */
    public static RuleScope mcc(String mcc) {
<span class="fc" id="L141">        return new RuleScope(Type.MCC, mcc);</span>
    }

    /**
     * Creates a logo scope.
     *
     * @param logo the card logo/brand
     * @return the logo scope
     */
    public static RuleScope logo(String logo) {
<span class="fc" id="L151">        return new RuleScope(Type.LOGO, logo);</span>
    }

    /**
     * Creates a multi-network scope.
     *
     * @param networks the card networks
     * @return the network scope
     */
    public static RuleScope networks(Set&lt;String&gt; networks) {
<span class="nc" id="L161">        return new RuleScope(Type.NETWORK, networks);</span>
    }

    /**
     * Creates a multi-MCC scope.
     *
     * @param mccs the merchant category codes
     * @return the MCC scope
     */
    public static RuleScope mccs(Set&lt;String&gt; mccs) {
<span class="nc" id="L171">        return new RuleScope(Type.MCC, mccs);</span>
    }

    /**
     * Creates a combined scope from multiple dimensions.
     *
     * @param dimensions map of dimension to allowed values
     * @return combined scope
     */
    public static RuleScope combined(Map&lt;String, Set&lt;String&gt;&gt; dimensions) {
<span class="fc" id="L181">        return new RuleScope(Type.COMBINED, null, null, dimensions);</span>
    }

    /**
     * Parses a scope object from JSON node.
     *
     * @param scopeNode the scope JSON object
     * @param mapper object mapper for value conversion
     * @return a RuleScope or null if invalid
     */
    public static RuleScope fromScopeNode(JsonNode scopeNode, ObjectMapper mapper) {
<span class="pc bpc" id="L192" title="1 of 6 branches missed.">        if (scopeNode == null || scopeNode.isNull() || scopeNode.isEmpty()) {</span>
<span class="fc" id="L193">            return RuleScope.GLOBAL;</span>
        }

<span class="fc" id="L196">        Map&lt;String, Set&lt;String&gt;&gt; dims = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L197">        addScopeValues(dims, scopeNode, &quot;network&quot;);</span>
<span class="fc" id="L198">        addScopeValues(dims, scopeNode, &quot;bin&quot;);</span>
<span class="fc" id="L199">        addScopeValues(dims, scopeNode, &quot;mcc&quot;);</span>
<span class="fc" id="L200">        addScopeValues(dims, scopeNode, &quot;logo&quot;);</span>

<span class="pc bpc" id="L202" title="1 of 2 branches missed.">        if (dims.isEmpty()) {</span>
<span class="nc" id="L203">            return RuleScope.GLOBAL;</span>
        }

<span class="fc bfc" id="L206" title="All 2 branches covered.">        if (dims.size() == 1) {</span>
<span class="fc" id="L207">            Map.Entry&lt;String, Set&lt;String&gt;&gt; entry = dims.entrySet().iterator().next();</span>
<span class="fc" id="L208">            String key = entry.getKey();</span>
<span class="fc" id="L209">            Set&lt;String&gt; values = entry.getValue();</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">            if (&quot;network&quot;.equals(key)) {</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">                return values.size() == 1 ? RuleScope.network(values.iterator().next()) : new RuleScope(Type.NETWORK, values);</span>
            }
<span class="nc bnc" id="L213" title="All 2 branches missed.">            if (&quot;bin&quot;.equals(key)) {</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">                return values.size() == 1 ? RuleScope.bin(values.iterator().next()) : new RuleScope(Type.BIN, values);</span>
            }
<span class="nc bnc" id="L216" title="All 2 branches missed.">            if (&quot;mcc&quot;.equals(key)) {</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">                return values.size() == 1 ? RuleScope.mcc(values.iterator().next()) : RuleScope.mccs(values);</span>
            }
<span class="nc bnc" id="L219" title="All 2 branches missed.">            if (&quot;logo&quot;.equals(key)) {</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">                return values.size() == 1 ? RuleScope.logo(values.iterator().next()) : new RuleScope(Type.LOGO, values);</span>
            }
        }

<span class="fc" id="L224">        return RuleScope.combined(dims);</span>
    }

    private static void addScopeValues(Map&lt;String, Set&lt;String&gt;&gt; dims, JsonNode scopeNode, String key) {
<span class="fc" id="L228">        JsonNode node = scopeNode.get(key);</span>
<span class="pc bpc" id="L229" title="1 of 4 branches missed.">        if (node == null || node.isNull()) {</span>
<span class="fc" id="L230">            return;</span>
        }
<span class="fc" id="L232">        Set&lt;String&gt; values = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">        if (node.isArray()) {</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">            for (JsonNode item : node) {</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">                if (item.isTextual()) {</span>
<span class="fc" id="L236">                    values.add(item.asText());</span>
                }
            }
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">        } else if (node.isTextual()) {</span>
<span class="fc" id="L240">            values.add(node.asText());</span>
        }
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">        if (!values.isEmpty()) {</span>
<span class="fc" id="L243">            dims.put(key, Set.copyOf(values));</span>
        }
<span class="fc" id="L245">    }</span>

    // ========== Matching ==========

    /**
     * Checks if this scope matches the given transaction attributes.
     *
     * @param network the transaction's card network
     * @param bin the transaction's BIN
     * @param mcc the transaction's MCC
     * @param logo the transaction's card logo
     * @return true if this scope matches the transaction
     */
    public boolean matches(String network, String bin, String mcc, String logo) {
<span class="pc bpc" id="L259" title="2 of 6 branches missed.">        return switch (type) {</span>
<span class="fc" id="L260">            case GLOBAL -&gt; true;</span>
<span class="fc" id="L261">            case NETWORK -&gt; matchesValue(network);</span>
<span class="fc" id="L262">            case BIN -&gt; matchesBin(bin);</span>
<span class="nc" id="L263">            case MCC -&gt; matchesValue(mcc);</span>
<span class="nc" id="L264">            case LOGO -&gt; matchesValue(logo);</span>
<span class="fc" id="L265">            case COMBINED -&gt; matchesCombined(network, bin, mcc, logo);</span>
        };
    }

    /**
     * Checks if the scope value matches the given value.
     */
    private boolean matchesValue(String transactionValue) {
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">        if (transactionValue == null) {</span>
<span class="nc" id="L274">            return false;</span>
        }
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">        if (value != null) {</span>
<span class="fc" id="L277">            return value.equalsIgnoreCase(transactionValue);</span>
        }
<span class="nc bnc" id="L279" title="All 2 branches missed.">        if (values != null) {</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">            for (String v : values) {</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">                if (v.equalsIgnoreCase(transactionValue)) {</span>
<span class="nc" id="L282">                    return true;</span>
                }
            }
        }
<span class="nc" id="L286">        return false;</span>
    }

    /**
     * Checks if the BIN matches (prefix matching).
     */
    private boolean matchesBin(String transactionBin) {
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">        if (transactionBin == null) {</span>
<span class="nc" id="L294">            return false;</span>
        }
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">        if (value != null) {</span>
<span class="fc" id="L297">            return transactionBin.startsWith(value);</span>
        }
<span class="nc bnc" id="L299" title="All 2 branches missed.">        if (values != null) {</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">            for (String prefix : values) {</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">                if (transactionBin.startsWith(prefix)) {</span>
<span class="nc" id="L302">                    return true;</span>
                }
            }
        }
<span class="nc" id="L306">        return false;</span>
    }

    /**
     * Checks combined scope matching (all dimensions must match).
     */
    private boolean matchesCombined(String network, String bin, String mcc, String logo) {
<span class="pc bpc" id="L313" title="2 of 4 branches missed.">        if (dimensions == null || dimensions.isEmpty()) {</span>
<span class="nc" id="L314">            return true;</span>
        }

<span class="fc bfc" id="L317" title="All 2 branches covered.">        for (Map.Entry&lt;String, Set&lt;String&gt;&gt; entry : dimensions.entrySet()) {</span>
<span class="fc" id="L318">            String key = entry.getKey();</span>
<span class="fc" id="L319">            Set&lt;String&gt; values = entry.getValue();</span>
<span class="pc bpc" id="L320" title="2 of 5 branches missed.">            boolean match = switch (key) {</span>
<span class="fc" id="L321">                case &quot;network&quot; -&gt; matchesValueSet(network, values);</span>
<span class="fc" id="L322">                case &quot;bin&quot; -&gt; matchesBinSet(bin, values);</span>
<span class="fc" id="L323">                case &quot;mcc&quot; -&gt; matchesValueSet(mcc, values);</span>
<span class="nc" id="L324">                case &quot;logo&quot; -&gt; matchesValueSet(logo, values);</span>
<span class="nc" id="L325">                default -&gt; false;</span>
            };
<span class="fc bfc" id="L327" title="All 2 branches covered.">            if (!match) {</span>
<span class="fc" id="L328">                return false;</span>
            }
        }
<span class="fc" id="L331">        return true;</span>
    }

    private boolean matchesValueSet(String transactionValue, Set&lt;String&gt; allowedValues) {
<span class="pc bpc" id="L335" title="3 of 6 branches missed.">        if (transactionValue == null || allowedValues == null || allowedValues.isEmpty()) {</span>
<span class="nc" id="L336">            return false;</span>
        }
<span class="fc bfc" id="L338" title="All 2 branches covered.">        for (String v : allowedValues) {</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">            if (v.equalsIgnoreCase(transactionValue)) {</span>
<span class="fc" id="L340">                return true;</span>
            }
        }
<span class="fc" id="L343">        return false;</span>
    }

    private boolean matchesBinSet(String transactionBin, Set&lt;String&gt; allowedValues) {
<span class="pc bpc" id="L347" title="3 of 6 branches missed.">        if (transactionBin == null || allowedValues == null || allowedValues.isEmpty()) {</span>
<span class="nc" id="L348">            return false;</span>
        }
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">        for (String prefix : allowedValues) {</span>
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">            if (transactionBin.startsWith(prefix)) {</span>
<span class="fc" id="L352">                return true;</span>
            }
        }
<span class="nc" id="L355">        return false;</span>
    }

    // ========== Getters ==========

    public Type getType() {
<span class="fc" id="L361">        return type;</span>
    }

    public String getValue() {
<span class="fc" id="L365">        return value;</span>
    }

    public Set&lt;String&gt; getValues() {
<span class="fc" id="L369">        return values;</span>
    }

    public Map&lt;String, Set&lt;String&gt;&gt; getDimensions() {
<span class="fc" id="L373">        return dimensions;</span>
    }

    /**
     * Gets the specificity level of this scope.
     * Higher values = more specific.
     */
    public int getSpecificity() {
<span class="fc" id="L381">        int base = type.getSpecificity();</span>
        // BIN length adds to specificity (longer BIN = more specific)
<span class="pc bpc" id="L383" title="1 of 4 branches missed.">        if (type == Type.BIN &amp;&amp; value != null) {</span>
<span class="fc" id="L384">            base += value.length();</span>
        }
<span class="pc bpc" id="L386" title="1 of 4 branches missed.">        if (type == Type.COMBINED &amp;&amp; dimensions != null) {</span>
<span class="fc" id="L387">            base += dimensions.size();</span>
        }
<span class="fc" id="L389">        return base;</span>
    }

    /**
     * Checks if this is a global scope.
     */
    public boolean isGlobal() {
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">        return type == Type.GLOBAL;</span>
    }

    // ========== Object Methods ==========

    private int computeHashCode() {
<span class="fc" id="L402">        return Objects.hash(type, value, values, dimensions);</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="fc bfc" id="L407" title="All 2 branches covered.">        if (this == o) return true;</span>
<span class="pc bpc" id="L408" title="2 of 4 branches missed.">        if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L409">        RuleScope ruleScope = (RuleScope) o;</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">        return type == ruleScope.type &amp;&amp;</span>
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">                Objects.equals(value, ruleScope.value) &amp;&amp;</span>
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">                Objects.equals(values, ruleScope.values) &amp;&amp;</span>
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">                Objects.equals(dimensions, ruleScope.dimensions);</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L418">        return hashCode;</span>
    }

    @Override
    public String toString() {
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">        if (type == Type.GLOBAL) {</span>
<span class="nc" id="L424">            return &quot;GLOBAL&quot;;</span>
        }
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">        if (value != null) {</span>
<span class="fc" id="L427">            return type.name() + &quot;:&quot; + value;</span>
        }
<span class="nc bnc" id="L429" title="All 2 branches missed.">        if (values != null) {</span>
<span class="nc" id="L430">            return type.name() + &quot;:&quot; + values;</span>
        }
<span class="nc bnc" id="L432" title="All 2 branches missed.">        if (dimensions != null) {</span>
<span class="nc" id="L433">            return type.name() + &quot;:&quot; + dimensions;</span>
        }
<span class="nc" id="L435">        return type.name();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>